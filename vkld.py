import xml.etree.ElementTree as ET
import re

h = open("vkld.h", "w")
h.write("""
/*
 * Copyright (c) 2020 WangBin <wbsecg1 at gmail.com>
 * generated by https://github.com/wang-bin/vkld
 */
""")

cpp = open("vkld.cpp", "w")
cpp_content = """
/*
 * Copyright (c) 2020 WangBin <wbsecg1 at gmail.com>
 * generated by https://github.com/wang-bin/vkld
 */
// we use c++ features without c++ runtime. so result binary can be used for c programs(linker option "-nostdlib++")
#if __has_include(<vulkan/vulkan_core.h>)
# include <vulkan/vulkan_core.h>
#endif
#if (VK_VERSION_1_0+0)
#if defined(_WIN32)
# include <windows.h>
# ifdef WINAPI_FAMILY
#  include <winapifamily.h>
#  if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
#    define VKLD_WINRT 1
#  endif
# endif
# if (VKLD_WINRT+0)
#   define dlopen(filename, flags) LoadPackagedLibrary(filename, 0)
# else
#   define dlopen(filename, flags) LoadLibrary(filename)
# endif
# define dlsym(handle, symbol) GetProcAddress((HMODULE)handle, symbol)
# define dlclose(handle) FreeLibrary((HMODULE)handle)
#else
# include <dlfcn.h>
#endif

static void init_vk();
static const struct vk_init {
    vk_init() {
        init_vk();
    }
} __;

struct vk_t {
#define EXPAND_VK(EXPR) decltype(&EXPR) p##EXPR = nullptr;
#include "vkld.h"
#undef EXPAND_VK
};
static vk_t vk;

void init_vk()
{
    constexpr const auto vkdso =
#if (_WIN32+0)
        TEXT("vulkan-1.dll")
#elif (__APPLE__+0)
        "libvulkan.1.dylib"
#elif (__ANDROID__+0)
        "libvulkan.so"
#else
        "libvulkan.so.1"
#endif
        ;
    auto libvulkan = dlopen(vkdso, RTLD_NOW | RTLD_LOCAL);
    if (!libvulkan)
        return;
#define EXPAND_VK(X) do { vk.p##X = (decltype(&X))dlsym(libvulkan, #X); } while (false);
#include "vkld.h"
#undef EXPAND_VK
}
extern "C" {
"""

tree = ET.parse('vk.xml')
root = tree.getroot()
commands = root.find('commands')
cmds = []
for cmd in commands.findall('command'):
    # If the <command> doesn't already have a 'name' attribute, set
    # it from contents of its <proto><name> tag.
    name = cmd.get('name')
    if name is None:
        name = cmd.find('proto/name').text

    if re.match('.*[A-Z]$', name): # name.endswith("KHR") or name.endswith("EXT") or name.endswith("NV"):
        continue
    alias = cmd.get('alias')
    if alias:
        continue

    h.write("""
EXPAND_VK({})""".format(name))

    proto = ET.SubElement(cmd, 'proto')
    ret = cmd.find('proto/type').text #ET.SubElement(proto,'type').text

    argtv = []
    argt = []
    argv = []
    params = []
    for par in cmd.findall('param'):
        argtv.append(re.sub(' +', ' ', ET.tostring(par, encoding="us-ascii", method="text").strip()))
        parname = par.find('name') #ET.SubElement(par, 'name')
        argv.append(parname.text.strip())
        par.remove(parname)
        argt.append(re.sub(' +', ' ', ET.tostring(par, encoding="us-ascii", method="text").strip()))
        p = {
            'type': ET.tostring(par, encoding="us-ascii", method="text"),
            'name': parname.text,
        }
        params.append(p)
    cpp_content += """
VKAPI_ATTR {ret} VKAPI_CALL {name}({argtv}) {{
    return vk.p{name}({argv});
}}
""".format(ret=ret, name=name, argtv=", ".join(argtv), argv=", ".join(argv))
    c = {
        'type': ret,
        'name': name,
        'argv': params
    }

cpp_content += """
} // extern "C"
#endif //(VK_VERSION_1_0+0)
"""
cpp.write(cpp_content)
h.close()
cpp.close()
